/*

    **使用说明：记得删除task"${workspaceFolder}/uBlock_128.cpp",以防重定义**
    主要修改：uBlock_128_KeySchedule添加轮密钥打印
             uBlock_128_Encrypt添加每轮密文打印
    测试所需参数，包括明文与密钥以参考文献为准
             
*/
#include <stdio.h>
#include <emmintrin.h>
#include <nmmintrin.h>

// 算法参数定义
__m128i S     = _mm_setr_epi8(0x7,0x4,0x9,0xc,0xb,0xa,0xd,0x8,0xf,0xe,0x1,0x6,0x0,0x3,0x2,0x5);
__m128i S_Inv = _mm_setr_epi8(0xc,0xa,0xe,0xd,0x1,0xf,0xb,0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x9,0x8);
__m128i con = _mm_set1_epi8(0x0f);
__m128i A1 = _mm_setr_epi8(1,2,3,4,5,6,7,0,9,10,11,12,13,14,15,8);  
__m128i A2 = _mm_setr_epi8(2,3,4,5,6,7,0,1,10,11,12,13,14,15,8,9);    
__m128i A3 = _mm_setr_epi8(5,6,7,0,1,2,3,4,13,14,15,8,9,10,11,12);    

// 全局变量
unsigned char Subkey[17][32];
unsigned char RC[16][16] = {0x9,0x8,0x8,0xc,0xc,0x9,0xd,0xd,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf,0x0,0xe,0x4,0xa,0x1,0xb,0x5,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x2,0x1,0x3,0x5,0x7,0x0,0x6,0x4,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x8,0x3,0x9,0x7,0xd,0x2,0xc,0x6,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xc,0x7,0xd,0x3,0x9,0x6,0x8,0x2,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x4,0xf,0x5,0xb,0x1,0xe,0x0,0xa,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x5,0xe,0x4,0xa,0x0,0xf,0x1,0xb,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x7,0xc,0x6,0x8,0x2,0xd,0x3,0x9,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x3,0x9,0x2,0xd,0x6,0x8,0x7,0xc,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xb,0x3,0xa,0x7,0xe,0x2,0xf,0x6,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xa,0x7,0xb,0x3,0xf,0x6,0xe,0x2,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x8,0xe,0x9,0xa,0xd,0xf,0xc,0xb,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xd,0xc,0xc,0x8,0x8,0xd,0x9,0x9,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x7,0x8,0x6,0xc,0x2,0x9,0x3,0xd,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x3,0x0,0x2,0x4,0x6,0x1,0x7,0x5,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xa,0x1,0xb,0x5,0xf,0x0,0xe,0x4,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
    

// 辅助打印函数
void print_block(const char* label, __m128i a, __m128i b) {
    unsigned char buf[32];
    _mm_storeu_si128((__m128i*)buf, a);
    _mm_storeu_si128((__m128i*)(buf+16), b);
    
    printf("%-5s", label);
    for(int i=0; i<16; i++) printf("%x", buf[i]);
    printf(" ");
    for(int i=16; i<32; i++) printf("%x", buf[i]);
    printf("\n");
}

// 修改后的密钥生成函数
void uBlock_128_KeySchedule(unsigned char *key) {
	int i;
	__m128i SK = _mm_setr_epi8(0, 2, 4, 6, 8, 10, 12, 14, 3, 1, 7, 5, 11, 9, 15, 13);

	__m128i c1 = _mm_setr_epi8(0, 0x80, 1, 0x80, 2, 0x80, 3, 0x80, 4, 0x80, 5, 0x80, 6, 0x80, 7, 0x80);	
	__m128i c2 = _mm_setr_epi8(0x80, 0, 0x80, 1, 0x80, 2, 0x80, 3, 0x80, 4, 0x80, 5, 0x80, 6, 0x80, 7);		
	__m128i c3 = _mm_setr_epi8(8, 0x80, 9, 0x80, 10, 0x80, 11, 0x80, 12, 0x80, 13, 0x80, 14, 0x80, 15, 0x80);		
	__m128i c4 = _mm_setr_epi8(0x80, 8, 0x80, 9, 0x80, 10, 0x80, 11, 0x80, 12, 0x80, 13, 0x80, 14, 0x80, 15);	

	__m128i c5 = _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80);	
	__m128i c6 = _mm_setr_epi8(0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 8, 9, 10, 11, 12, 13, 14, 15);	
	__m128i c7 = _mm_setr_epi8(8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7);	
	__m128i c8 = _mm_setr_epi8(6,0,8,13,1,15,5,10,4,9,12,2,11,3,7,14);	

	__m128i state1, state2, k, t1, t2, t3, t4;  

	state2 = _mm_loadu_si128((__m128i*)key);
	state1 = _mm_srli_epi16(state2, 4);
	state1 = _mm_and_si128(state1, con);
	state2 = _mm_and_si128(state2, con);
	t1 = _mm_shuffle_epi8(state1, c1);
	t2 = _mm_shuffle_epi8(state2, c2);
	t3 = _mm_shuffle_epi8(state1, c3);
	t4 = _mm_shuffle_epi8(state2, c4);
	state1 = _mm_xor_si128(t1, t2);
	state2 = _mm_xor_si128(t3, t4);

	_mm_storeu_si128((__m128i*)Subkey[0], state1);
	_mm_storeu_si128((__m128i*)(Subkey[0] + 16), state2);

	for (i = 1; i <= 16; i++)
	{
		state1 = _mm_shuffle_epi8(state1, c8);

		k = _mm_loadu_si128((__m128i*)RC[i - 1]);
		k = _mm_xor_si128(k, state1);
		t1 =  _mm_shuffle_epi8(S, k);
		t2 = _mm_shuffle_epi8(SK, k);
		t3 = _mm_shuffle_epi8(t1, c5);
		t4 = _mm_shuffle_epi8(t2, c6);
		k = _mm_xor_si128(t3, t4);

		k = _mm_xor_si128(k, state2);
		state2 = _mm_shuffle_epi8(state1, c7);
		state1 = k;

		_mm_storeu_si128((__m128i*)Subkey[i], state1);
		_mm_storeu_si128((__m128i*)(Subkey[i] + 16), state2);
	}

    // 添加轮密钥打印
    printf("轮密钥与每轮输出状态：\n");
    for (int i = 0; i < 17; i++) {
        printf("RK[%-2d] ", i);
        for (int j = 0; j < 16; j++) {
            printf("%x", Subkey[i][j]);
        }
        printf(" ");
        for (int j = 16; j < 32; j++) {
            printf("%x", Subkey[i][j]);
        }
        printf("\n");
    }

    return;
}

// 修改后的加密函数
void uBlock_128_Encrypt(unsigned char *plain, unsigned char *cipher, int round) {
	int i;
	__m128i L1 = _mm_setr_epi8(2,3,6,7,8,9,12,13,0,1,4,5,14,15,10,11);		
	__m128i L2 = _mm_setr_epi8(4,5,14,15,10,11,0,1,2,3,12,13,8,9,6,7);	

	__m128i c1 = _mm_setr_epi8(0, 0x80, 1, 0x80, 2, 0x80, 3, 0x80, 4, 0x80, 5, 0x80, 6, 0x80, 7, 0x80);	
	__m128i c2 = _mm_setr_epi8(0x80, 0, 0x80, 1, 0x80, 2, 0x80, 3, 0x80, 4, 0x80, 5, 0x80, 6, 0x80, 7);		
	__m128i c3 = _mm_setr_epi8(8, 0x80, 9, 0x80, 10, 0x80, 11, 0x80, 12, 0x80, 13, 0x80, 14, 0x80, 15, 0x80);		
	__m128i c4 = _mm_setr_epi8(0x80, 8, 0x80, 9, 0x80, 10, 0x80, 11, 0x80, 12, 0x80, 13, 0x80, 14, 0x80, 15);	

	__m128i c5 = _mm_setr_epi8(0, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80);	
	__m128i c6 = _mm_setr_epi8(0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0, 2, 4, 6, 8, 10, 12, 14);		
	__m128i c7 = _mm_setr_epi8(1, 3, 5, 7, 9, 11, 13, 15, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80);		
	__m128i c8 = _mm_setr_epi8(0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 1, 3, 5, 7, 9, 11, 13, 15);		

	__m128i state1, state2, k, t1, t2, t3, t4;  

	state2 = _mm_loadu_si128((__m128i*)plain);
	state1 = _mm_srli_epi16(state2, 4);
	state1 = _mm_and_si128(state1, con);
	state2 = _mm_and_si128(state2, con);
	t1 = _mm_shuffle_epi8(state1, c1);
	t2 = _mm_shuffle_epi8(state2, c2);
	t3 = _mm_shuffle_epi8(state1, c3);
	t4 = _mm_shuffle_epi8(state2, c4);
	state1 = _mm_xor_si128(t1, t2);
	state2 = _mm_xor_si128(t3, t4);

    print_block(" X[0 ] ", state1, state2);
    
    for (i = 0; i < round; i++) {
	    k = _mm_loadu_si128((__m128i*)Subkey[i]);
		state1 = _mm_xor_si128(state1, k);
		k = _mm_loadu_si128((__m128i*)(Subkey[i] + 16));
		state2 = _mm_xor_si128(state2, k);

		state1 = _mm_shuffle_epi8(S, state1);
		state2 = _mm_shuffle_epi8(S, state2);

		state2 = _mm_xor_si128(state2, state1);
		k = _mm_shuffle_epi8(state2, A1);
		state1 = _mm_xor_si128(state1, k);
		k = _mm_shuffle_epi8(state1, A2);
		state2 = _mm_xor_si128(state2, k);
		k = _mm_shuffle_epi8(state2, A2);
		state1 = _mm_xor_si128(state1, k);
		k = _mm_shuffle_epi8(state1, A3);
		state2 = _mm_xor_si128(state2, k);
		state1 = _mm_xor_si128(state1, state2);

		state1 = _mm_shuffle_epi8(state1, L1);
		state2 = _mm_shuffle_epi8(state2, L2);
        char str[10]={0};
        snprintf(str, sizeof(str), " X[%-2d] ", i+1);
        print_block(str, state1, state2); // 根据实际轮数调整索引
    }
    
	if(round == 16)
	{
		k = _mm_loadu_si128((__m128i*)Subkey[round]);
		state1 = _mm_xor_si128(state1, k);
		k = _mm_loadu_si128((__m128i*)(Subkey[round] + 16));
		state2 = _mm_xor_si128(state2, k);
	}

	t1 = _mm_shuffle_epi8(state1, c5);
	t2 = _mm_shuffle_epi8(state2, c6);
	t3 = _mm_shuffle_epi8(state1, c7);
	t4 = _mm_shuffle_epi8(state2, c8);

	state1 = _mm_xor_si128(t1, t2);
	state2 = _mm_xor_si128(t3, t4);

	state1 = _mm_slli_epi16(state1, 4);
	state1 = _mm_xor_si128(state1, state2);

	_mm_storeu_si128((__m128i*)cipher, state1);

	return;
}

// 测试用例
int main() {
    unsigned char plain[16] = {
        0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,
        0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10
    };
    
    unsigned char key[16] = {
        0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,
        0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10
    };
    
    unsigned char cipher[16];

    // 执行加密
    uBlock_128_KeySchedule(key);
    uBlock_128_Encrypt(plain, cipher, 16);
    
    // 打印最终密文
    printf(" 密文Y ");
    for(int i=0; i<8; i++) printf("%02x", cipher[i]);
    putchar(' ');
    for(int i=8; i<16; i++) printf("%02x", cipher[i]);
    printf("\n");
	
    return 0;
}